package csskit

import (
	"bufio"
	"fmt"
	"io"
	"slices"
	"strconv"
	"strings"
)

var unitOrder = map[string]int{
	"px":  0,
	"%":   1,
	"vw":  2,
	"vh":  3,
	"rad": 4,
	"deg": 5,
	"ms":  6,
	"s":   7,
}

type parsedToken struct {
	Type      TokenType
	TextValue string
	NumValue  float32
}

type cssClass struct {
	Name   string
	Tokens []parsedToken
	Props  []CSSProperty
}

func GenerateCSS(w io.Writer, rcs []RawCSSClass) error {
	bw := bufio.NewWriter(w)

	_, err := fmt.Fprintln(bw, "/* Code generated by CSSKit - DO NOT EDIT. */")
	if err != nil {
		return err
	}

	classMap := make(map[string]struct{})
	var classes []cssClass
	for _, rc := range rcs {
		key, err := getClassKey(rc.Tokens)
		if err != nil {
			return err
		}
		if _, exists := classMap[key]; exists {
			continue
		} else {
			classMap[key] = struct{}{}
		}
		class, err := parseCSSClass(rc)
		if err != nil {
			return err
		}
		classes = append(classes, class)
	}

	slices.SortFunc(classes, compareClass)

	for _, class := range classes {
		_, err := fmt.Fprintf(bw, "\n.%s {\n", class.Name)
		if err != nil {
			return err
		}
		for _, prop := range class.Props {
			_, err = fmt.Fprintf(bw, "    %s: %s;\n", prop.Property, prop.Value)
			if err != nil {
				return err
			}
		}
		_, err = fmt.Fprintln(bw, "}")
		if err != nil {
			return err
		}
	}

	return bw.Flush()
}

func getClassKey(tokens []Token) (string, error) {
	var sb strings.Builder
	for _, tok := range tokens {
		if _, err := sb.WriteString(tok.Value); err != nil {
			return "", err
		}
	}
	return sb.String(), nil
}

func compareClass(a, b cssClass) int {
	tokCountA := len(a.Tokens)
	tokCountB := len(b.Tokens)
	minTokCount := min(tokCountA, tokCountB)

	unitA := ""
	unitB := ""
	if a.Tokens[tokCountA-1].Type == TokenUnit {
		unitA = a.Tokens[tokCountA-1].TextValue
	}
	if b.Tokens[tokCountB-1].Type == TokenUnit {
		unitB = b.Tokens[tokCountB-1].TextValue
	}

	for i := 0; i < minTokCount; i++ {
		tokA := a.Tokens[i]
		tokB := b.Tokens[i]

		if tokA.Type == TokenKeyword && tokB.Type == TokenKeyword {
			res := compareStrings(tokA.TextValue, tokB.TextValue)
			if res == 0 {
				continue
			} else {
				return res
			}
		}
		if tokA.Type == TokenNumber && tokB.Type == TokenNumber {
			if unitA == unitB {
				res := compareFloats(tokA.NumValue, tokB.NumValue)
				if res == 0 {
					continue
				} else {
					return res
				}
			}
			if unitA == "" && unitB != "" {
				return -1
			}
			if unitA != "" && unitB == "" {
				return 1
			}
			return compareUnits(unitA, unitB)
		}
		if tokA.Type == TokenKeyword && tokB.Type == TokenNumber {
			return 1
		}
		if tokA.Type == TokenNumber && tokB.Type == TokenKeyword {
			return -1
		}
		if tokA.Type == TokenHyphen && tokB.Type == TokenHyphen {
			continue
		}
		if tokA.Type == TokenHyphen && tokB.Type == TokenUnit {
			return 1
		}
		if tokA.Type == TokenUnit && tokB.Type == TokenHyphen {
			return -1
		}

		typeNameA := GetTokenTypeName(tokA.Type)
		typeNameB := GetTokenTypeName(tokB.Type)
		err := fmt.Errorf("unexpected comparison between %q and	%q tokens", typeNameA, typeNameB)
		panic(err)
	}

	panic(fmt.Errorf("unexpected comparison between the same class"))
}

func compareStrings(a, b string) int {
	if a < b {
		return -1
	} else if a > b {
		return 1
	}
	return 0
}

func compareFloats(a, b float32) int {
	if a < b {
		return -1
	} else if a > b {
		return 1
	}
	return 0
}

func compareUnits(a, b string) int {
	posA, okA := unitOrder[a]
	posB, okB := unitOrder[b]

	if !okA {
		panic(fmt.Errorf("unrecognized unit: %s", a))
	}
	if !okB {
		panic(fmt.Errorf("unrecognized unit: %s", b))
	}

	if posA < posB {
		return -1
	} else if posA > posB {
		return 1
	}
	return 0
}

func parseCSSClass(rc RawCSSClass) (cssClass, error) {
	var sb strings.Builder
	toks := make([]parsedToken, len(rc.Tokens))
	props := slices.Clone(rc.Props)

	for i, rtok := range rc.Tokens {
		if _, err := sb.WriteString(rtok.Value); err != nil {
			return cssClass{}, err
		}

		tok := parsedToken{Type: rtok.Type}
		switch tok.Type {
		case TokenKeyword, TokenUnit, TokenHyphen:
			tok.TextValue = rtok.Value
		case TokenNumber:
			n, err := strconv.ParseFloat(rtok.Value, 32)
			if err != nil {
				return cssClass{}, err
			}
			tok.NumValue = float32(n)
		default:
			typeName := GetTokenTypeName(tok.Type)
			err := fmt.Errorf("unexpected token type: %s", typeName)
			return cssClass{}, err
		}
		toks[i] = tok
	}

	identifier := escapeIdentifier(sb.String())
	return cssClass{Name: identifier, Tokens: toks, Props: props}, nil
}

func escapeIdentifier(input string) string {
	var sb strings.Builder
	sb.Grow(len(input))
	for _, c := range input {
		switch c {
		case '%':
			sb.WriteString(`\%`)
		case '.':
			sb.WriteString(`\.`)
		default:
			sb.WriteRune(c)
		}
	}
	return sb.String()
}
